<!doctype html>
<html lang="pt-BR">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Timeline — comportamento ajustado</title>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --control-gutter: 64px;
      --card-width: 430px;
      --card-gap: 0px;
      /* distância horizontal entre cards */
      --parallax: 0.78;
      --stage-gutter: 96px;
      --fg: 255, 255, 255;
      --muted-white: 255, 255, 255;
      --accent: 245, 25, 25;
    }

    * {
      box-sizing: border-box
    }

    body {
      margin: 0;
      font-family: "Montserrat", Inter, system-ui, -apple-system, "Segoe UI", Roboto;


    }

    /* LAYOUT */
    .timeline-section {
      padding: 0
    }

    .tl-wrap {
      width: 100%;
      padding: 0 20px
    }

    .tl-viewport {
      position: relative;
      height: 100vh;
      overflow: hidden;
      padding: 100px var(--control-gutter);
      outline: none;
      background: transparent;
    }

    .tl-stage {
      position: relative;
      width: 100%;
      height: calc(100vh - 200px);
      overflow: visible;
    }

    /* SVG (linha) - ajustado dinamicamente via JS */
    .tl-bg {
      position: absolute;
      left: 0;
      top: 60%;
      transform: translateY(-50%) translateX(0);
      height: 200px;
      width: 10px;
      pointer-events: none;
      user-select: none;
      will-change: transform;
      z-index: 0;
      opacity: 0.95;
      filter: drop-shadow(0 8px 24px rgba(0, 0, 0, 0.22));
      margin: 0px 100px 0px 100px;
    }

    /* TRACK: o elemento que corre horizontalmente (flex) */
    .tl-track {
      padding-left: 100px;
      padding-top: 130px;
      position: relative;
      display: flex;
      align-items: center;
      gap: var(--card-gap);
      height: 80%;
      /* largura definida pelo conteúdo */
      z-index: 2;
      /* acima do bg */
      will-change: transform;
      transform: translate3d(0, 0, 0);
    }

    /* margem inicial equivalente ao gutter (para alinhar start) */
    .tl-track::before {
      content: '';
      display: block;
      width: calc(var(--stage-gutter));
      height: 1px
    }

    .tl-track::after {
      content: '';
      display: block;
      width: 160px;
      height: 1px
    }

    /* end padding por padrão */

    /* INTRO: agora é item normal do fluxo (se comporte como tl-item) */
    .tl-intro-item {
      min-width: 420px;
      padding: 10px 0;
      align-self: flex-start;
      z-index: 6;
      /* mais alto para legibilidade */

    }

    .tl-intro-small {
      font-size: 22px;
      color: rgba(var(--muted-white), 0.92);
      display: block
    }

    .tl-intro-main {
      display: flex;
      align-items: baseline;
      gap: 8px
    }

    .tl-slash {
      color: rgb(var(--accent));
      font-weight: 800;
      font-size: 55px
    }

    .tl-intro-title {
      margin: 0;
      font-size: 64px;
      font-weight: 700;
      color: rgba(var(--fg), 1)
    }

    .tl-intro-sub {
      margin-top: 6px;
      font-size: 14px;
      color: rgba(var(--fg), 0.85);
      max-width: 420px
    }

    /* CARD */
    .tl-item {
      min-width: var(--card-width);
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.02), rgba(255, 255, 255, 0.01));
      border-radius: 20px;
      border: 1px solid rgba(255, 255, 255, 0.06);
      padding: 28px;
      display: flex;
      gap: 12px;
      align-items: flex-start;
      box-sizing: border-box;
      cursor: pointer;
      opacity: 0.86;
      transition: transform .36s cubic-bezier(.2, .9, .25, 1), opacity .36s, box-shadow .28s;
      backdrop-filter: blur(6px) saturate(115%);
      text-shadow: 0 6px 16px rgba(0, 0, 0, 0.45);
      margin: 0px 50px 0px 50px;
    }



    #card-4 {
      margin: 0px 0px 0px 300px;
    }


    .tl-item-icon {
      width: 50px;
      height: 50px;
      flex: 0 0 36px;
      object-fit: contain;
      margin-right: 12px
    }

    .tl-item-body {
      display: block
    }

    .tl-item-title {
      margin: 0 0 6px 0;
      font-size: 16px;
      font-weight: 700;
      color: rgba(var(--fg), 1)
    }

    .tl-item-desc {
      margin: 0;
      font-size: 13px;
      color: rgba(var(--fg), 0.86);
      line-height: 1.45
    }

    /* top / bottom: controle vertical */
    .tl-item.top {
      align-self: flex-start;
      margin-top: -36px;
      z-index: 5
    }

    /* aparece acima da linha */
    .tl-item.bottom {
      align-self: flex-end;
      margin-bottom: -36px;
      z-index: 3
    }

    /* aparece abaixo da linha */

    /* item ativo mais destacado */
    .tl-item.active {
      transform: translateY(-8px) scale(1.02);
      opacity: 1;
      box-shadow: 0 24px 60px rgba(0, 0, 0, 0.45);
      z-index: 7
    }

    /* seta final (opcional) */
    .end-arrow {
      position: fixed;
      left: 50%;
      bottom: 28px;
      transform: translateX(-50%) translateY(14px);
      opacity: 0;
      pointer-events: none;
      transition: transform .28s ease, opacity .28s ease;
      z-index: 9999
    }

    .end-arrow.visible {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
      pointer-events: auto
    }

    /* responsive mobile: volta ao fluxo normal */
    @media (max-width:720px) {
      .tl-viewport {
        height: auto;
        padding: 20px
      }

      .tl-stage {
        height: auto
      }



      /* wrapper absoluto que posiciona o SVG exatamente como antes */
.tl-bg-wrap {
  position: absolute;
  left: 100;
  top: 60%;
  transform: translateY(-50%);
  height: 200px;           /* mantém o que você tinha */
  pointer-events: none;
  user-select: none;
  will-change: transform;
  z-index: 0;
  opacity: 0.95;
  filter: drop-shadow(0 8px 24px rgba(0,0,0,0.22));
  padding: 0px 100px 0px 100px;
}

/* a própria imagem dentro do wrapper */
.tl-bg {
  display: block;
  height: 100%;
  width: 10px; /* seu valor original */
}

/* bloco invisível lateral — ajuste --tl-bg-extra para o espaçamento desejado.
   Pode usar px ou vw (ex: 40px ou 5vw) */
.tl-bg-wrap::after {
  content: "";
  position: absolute;
  left: 100%;                      /* começa logo depois da imagem */
  top: 0;
  width: var(--tl-bg-extra, 40px); /* largura do "margem" invisível */
  height: 100%;
  pointer-events: none;            /* não bloqueia interações */
  /* background: transparent; */   /* invisível por padrão */
}


      .tl-track {
        display: block;
        gap: 12px;
        width: 100%
      }

      .tl-track::before,
      .tl-track::after {
        display: none
      }

      .tl-intro-item {
        position: static;
        transform: none;
        margin-bottom: 12px;
        z-index: 3
      }

      .tl-item {
        width: 100%;
        min-width: unset;
        position: static;
        transform: none
      }

      .end-arrow {
        display: none
      }
    }

    /* bloco depois (exemplo) */
    .after {
      padding: 80px 20px;
      background: #fff;
      color: #111;
      min-height: 600px;
      margin-top: 40px
    }
  </style>
</head>

<body>

  <!-- Defina data-end-extra-px ou data-end-extra-vw no section para controlar onde parar -->
  <section id="timeline" class="timeline-section" aria-label="Linha do tempo DevSecOps" data-end-extra-px="300" <!-- ex:
    300px extras -->
    <!-- data-end-extra-vw="20" --> <!-- ou ex: 20 (vw) -->
   
    <div class="tl-bg-wrap" aria-hidden="true">
      <div class="tl-viewport" tabindex="0" aria-label="Linha do tempo horizontal com cards explicativos">
        <div class="tl-stage">

          <!-- SVG da linha (coloquei DEPOIS do track no DOM para garantir z-index correto, mas fica absoluto por CSS) -->
              <img class="tl-bg" id="tlBg" src="{{ url_for('static', filename='images/corpo/imagens/timeline.svg') }}"
                  alt="" role="presentation" loading="eager">
          <!-- TRACK: aqui vai a ordem HORIZONTAL real (1,2,3,4 etc).
             cada item pode ter .top ou .bottom para controlar verticalidade. -->
          <div class="tl-track" id="tlTrack" role="list" aria-hidden="false">

            <!-- INTRO agora é item normal no fluxo (vai se mover com o track)
               Se quiser que fique exatamente alinhado com o começo, o ::before do track cria o gutter. -->
            <div class="tl-intro-item" role="article" aria-label="Introdução DevSecOps">
              <div class="tl-intro-inner">
                <div class="tl-intro-head">
                  <span class="tl-intro-small">O que é</span>
                  <div class="tl-intro-main">
                    <span class="tl-slash">/</span>
                    <h2 class="tl-intro-title"><strong>DevSecOps?</strong></h2>
                  </div>
                </div>
                <p class="tl-intro-sub">Percorra a linha do tempo para ver os conceitos e práticas que compõem
                  DevSecOps.</p>
              </div>
            </div>

            <!-- HORIZONTAL ORDER: card 1 (primeiro) - VERTICAL: bottom (embaixo da linha) -->
            <article class="tl-item bottom" role="listitem" data-step="1" aria-label="Passo 1">
              <img class="tl-item-icon" src="{{ url_for('static', filename='images/corpo/icons/Juncao.svg') }}"
                alt="" aria-hidden="true" />
              <div class="tl-item-body">
                <h3 class="tl-item-title">Passo 1</h3>
                <p class="tl-item-desc">Descrição do passo 1 (bottom).</p>
              </div>
            </article>

            <!-- HORIZONTAL ORDER: card 2 (segundo) - VERTICAL: top (acima da linha) -->
            <article class="tl-item top" role="listitem" data-step="2" aria-label="Passo 2">
              <img class="tl-item-icon" src="{{ url_for('static', filename='images/corpo/icons/Seguranca.svg') }}"
                alt="" aria-hidden="true" />
              <div class="tl-item-body">
                <h3 class="tl-item-title">Passo 2</h3>
                <p class="tl-item-desc">Descrição do passo 2 (top).</p>
              </div>
            </article>

            <!-- HORIZONTAL ORDER: card 3 (terceiro) - VERTICAL: bottom -->
            <article class="tl-item bottom" role="listitem" data-step="3" aria-label="Passo 3">
              <img class="tl-item-icon" src="{{ url_for('static', filename='images/corpo/icons/Automacao.svg') }}"
                alt="" aria-hidden="true" />
              <div class="tl-item-body">
                <h3 class="tl-item-title">Passo 3</h3>
                <p class="tl-item-desc">Descrição do passo 3 (bottom).</p>
              </div>
            </article>

            <!-- HORIZONTAL ORDER: card 4 (quarto) - VERTICAL: top -->
            <article class="tl-item top"  id="card-4" role="listitem" data-step="4" aria-label="Passo 4">
              <img class="tl-item-icon" src="{{ url_for('static', filename='images/corpo/icons/Correcoes.svg') }}"
                alt="" aria-hidden="true" />
              <div class="tl-item-body">
                <h3 class="tl-item-title">Passo 4</h3>
                <p class="tl-item-desc">Descrição do passo 4 (top).</p>
              </div>
            </article>

            <!-- adicione mais cards seguindo o padrão (ordem horizontal = ordem do DOM) -->
          </div> <!-- .tl-track -->

        </div> <!-- .tl-stage -->
      </div> <!-- .tl-viewport -->
    </div> <!-- .tl-wrap -->
  </section>

  <!-- seta final (opcional) -->
  <div class="end-arrow" id="endArrow" aria-hidden="true">
    <svg width="36" height="36" viewBox="0 0 24 24" fill="none" aria-hidden="true">
      <path d="M12 4v14" stroke="#fff" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"></path>
      <path d="M6 12l6 6 6-6" stroke="#fff" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"></path>
    </svg>
  </div>

  <!-- GSAP + ScrollTrigger -->
  <script src="https://unpkg.com/gsap@3/dist/gsap.min.js"></script>
  <script src="https://unpkg.com/gsap@3/dist/ScrollTrigger.min.js"></script>

  <script>
    (function () {
      gsap.registerPlugin(ScrollTrigger);

      const section = document.getElementById('timeline');
      if (!section) return;

      const viewport = section.querySelector('.tl-viewport');
      const stage = section.querySelector('.tl-stage');
      const track = document.getElementById('tlTrack');
      const bg = document.getElementById('tlBg');
      const items = Array.from(track.querySelectorAll('.tl-item, .tl-intro-item'));
      const endArrow = document.getElementById('endArrow');

      const PARALLAX = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--parallax')) || 0.78;

      // lê configuração extra de scroll (px ou vw)
      function getEndExtra() {
        const px = parseFloat(section.dataset.endExtraPx);
        if (!Number.isNaN(px) && px > 0) return px;
        const vw = parseFloat(section.dataset.endExtraVw);
        if (!Number.isNaN(vw) && vw > 0) return (vw / 100) * window.innerWidth;
        return 1600; // default
      }

      let tween = null, monitor = null;

      function setup() {
        // limpa instâncias anteriores
        ScrollTrigger.getAll().forEach(t => t.kill());
        gsap.killTweensOf(track);

        // mobile fallback
        if (window.matchMedia('(max-width:720px)').matches) {
          track.style.transform = 'none';
          if (bg) bg.style.transform = 'translateY(-50%) translateX(0)';
          items.forEach(i => i.classList.remove('active'));
          if (endArrow) endArrow.classList.remove('visible');
          return;
        }

        // calcula largura total do track (conteúdo)
        const totalContentWidth = track.scrollWidth; // inclui padding pseudo ::before/after visual
        const vw = viewport.clientWidth;
        const extra = Math.max(0, getEndExtra());
        const distance = Math.max(0, totalContentWidth - vw + extra);

        // ajusta largura do SVG para cobrir track + extra, para permitir ponta alinhar
        if (bg) {
          const bgWidth = Math.max(totalContentWidth + extra, vw);
          bg.style.width = bgWidth + 'px';
          bg.style.minWidth = bgWidth + 'px';
        }

        if (distance === 0) {
          track.style.transform = 'none';
          if (bg) bg.style.transform = 'translateY(-50%) translateX(0)';
          return;
        }

        // cria tween principal: move o track horizontalmente de 0 -> -distance
        tween = gsap.to(track, {
          x: -distance,
          ease: 'none',
          force3D: true,
          onUpdate: updateUI,
          scrollTrigger: {
            trigger: viewport,
            start: 'top top',
            end: () => '+=' + distance,
            scrub: 0.6,
            pin: viewport,
            anticipatePin: 1,
            invalidateOnRefresh: true,
            onRefresh: updateUI
          }
        });

        // monitor: mostra a seta final e permite ações quando no fim
        monitor = ScrollTrigger.create({
          trigger: viewport,
          start: 'top top',
          end: () => '+=' + distance,
          onLeave: () => { if (endArrow) endArrow.classList.add('visible'); },
          onEnterBack: () => { if (endArrow) endArrow.classList.remove('visible'); },
          onUpdate: st => {
            if (endArrow) {
              if (st.progress >= 0.99) endArrow.classList.add('visible'); else endArrow.classList.remove('visible');
            }
          }
        });

        updateUI(); // define estado inicial
      }

      // atualiza active + parallax do bg
      function updateUI() {
        // 1) active: card mais próximo do centro
        const vpRect = viewport.getBoundingClientRect();
        const centerX = vpRect.left + vpRect.width / 2;

        let closest = null, minDist = Infinity;
        items.forEach(it => {
          const r = it.getBoundingClientRect();
          const itemCenter = r.left + (r.width / 2);
          const d = Math.abs(itemCenter - centerX);
          if (d < minDist) { minDist = d; closest = it; }
        });
        items.forEach(it => it.classList.toggle('active', it === closest));

        // 2) parallax: move bg de 0 -> finalShift * PARALLAX
        if (bg && tween && tween.scrollTrigger) {
          const prog = tween.scrollTrigger.progress || 0;
          const bgWidth = bg.getBoundingClientRect().width || bg.clientWidth || 0;
          const vw = viewport.clientWidth;
          // finalShift coloca a Borda DIREITA do SVG alinhada ao centro da viewport
          // assumimos ponta da seta no extremo direito do SVG. Se não for, me manda o SVG inline e ajusto via getBBox().
          const finalShift = (vw / 2) - bgWidth;
          const shift = prog * finalShift * PARALLAX;
          bg.style.transform = `translateY(-50%) translateX(${shift}px)`;
        }
      }

      // inicializa
      window.addEventListener('load', setup);
      window.addEventListener('resize', () => {
        clearTimeout(window._tl_resize);
        window._tl_resize = setTimeout(setup, 150);
      });

      // acessibilidade: ao clicar em um card, centraliza ele (útil)
      track.addEventListener('click', (e) => {
        const card = e.target.closest('.tl-item, .tl-intro-item');
        if (!card) return;
        // centraliza o card suavemente usando a posição atual do track transform
        const vpRect = viewport.getBoundingClientRect();
        const centerX = vpRect.left + vpRect.width / 2;
        const r = card.getBoundingClientRect();
        const cardCenter = r.left + (r.width / 2);
        const delta = cardCenter - centerX;
        // deslocamos o track por delta (transform current - delta)
        // melhor usar scrollTo do ScrollTrigger para mover o document's scroll so Scrub updates properly:
        if (tween && tween.scrollTrigger) {
          const st = tween.scrollTrigger;
          const currentProgress = st.progress;
          const distance = Math.max(0, track.scrollWidth - viewport.clientWidth + getEndExtra());
          // calculamos target progress aproximado:
          const currentX = - (distance * currentProgress);
          const targetX = currentX - delta; // negative to move left when card is right of center
          const targetProg = Math.min(1, Math.max(0, -targetX / distance));
          // anima a posição do scrollTrigger (via scrollTo)
          gsap.to(window, { scrollTo: st.start + (distance * targetProg), duration: 0.6, ease: 'power2.out' });
        }
      });

    })();
  </script>

  <!-- OBS: se seu projeto NÃO tem plugin ScrollToPlugin, comente a última função de centralizar (ou importe ScrollToPlugin).
     A centralização por clique funciona melhor com ScrollToPlugin. -->

</body>

</html>
