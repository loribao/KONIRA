<!doctype html>
<html lang="pt-BR">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Timeline — comportamento ajustado</title>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="{{ url_for('static', filename='css/corpo4.css') }}">
</head>

<body>
  <section id="timeline" class="timeline-section" aria-label="Linha do tempo DevSecOps" data-end-extra-px="1000">
    <div class="tl-bg-wrap" aria-hidden="true">
      <div class="tl-viewport" tabindex="0" aria-label="Linha do tempo horizontal com cards explicativos">
        <div class="tl-stage">
          <img class="tl-bg" id="tlBg" src="{{ url_for('static', filename='images/corpo/bloco4/timeline.svg') }}"
            alt="" role="presentation" loading="eager" data-tip-percent="100">
          <div class="tl-track" id="tlTrack" role="list" aria-hidden="false">
            <div class="tl-intro-item" role="article" aria-label="Introdução DevSecOps">
              <div class="tl-intro-inner">
                <div class="tl-intro-head">
                  <span class="tl-intro-small">O que é</span>
                  <div class="tl-intro-main">
                    <span class="tl-slash">/</span>
                    <h2 class="tl-intro-title"><strong>DevSecOps?</strong></h2>
                  </div>
                </div>
                <p class="tl-intro-sub">Percorra a linha do tempo para ver os conceitos e práticas que compõem
                  DevSecOps.</p>
              </div>
            </div>

            <article class="tl-item bottom" role="listitem" data-step="1" aria-label="Passo 1">
              <img class="tl-item-icon" src="{{ url_for('static', filename='images/corpo/bloco4/Juncao.svg') }}" alt=""
                aria-hidden="true" />
              <div class="tl-item-body">
                <h3 class="tl-item-title">Passo 1</h3>
                <p class="tl-item-desc">Descrição do passo 1 (bottom).</p>
              </div>
            </article>

            <article class="tl-item top" role="listitem" data-step="2" aria-label="Passo 2">
              <img class="tl-item-icon" src="{{ url_for('static', filename='images/corpo/bloco4/Seguranca.svg') }}"
                alt="" aria-hidden="true" />
              <div class="tl-item-body">
                <h3 class="tl-item-title">Passo 2</h3>
                <p class="tl-item-desc">Descrição do passo 2 (top).</p>
              </div>
            </article>

            <article class="tl-item bottom" role="listitem" data-step="3" aria-label="Passo 3">
              <img class="tl-item-icon" src="{{ url_for('static', filename='images/corpo/bloco4/Automacao.svg') }}"
                alt="" aria-hidden="true" />
              <div class="tl-item-body">
                <h3 class="tl-item-title">Passo 3</h3>
                <p class="tl-item-desc">Descrição do passo 3 (bottom).</p>
              </div>
            </article>

            <article class="tl-item top" id="card-4" role="listitem" data-step="4" aria-label="Passo 4">
              <img class="tl-item-icon" src="{{ url_for('static', filename='images/corpo/bloco4/Correcoes.svg') }}"
                alt="" aria-hidden="true" />
              <div class="tl-item-body">
                <h3 class="tl-item-title">Passo 4</h3>
                <p class="tl-item-desc">Descrição do passo 4 (top).</p>
              </div>
            </article>

          </div> <!-- .tl-track -->

        </div> <!-- .tl-stage -->
      </div> <!-- .tl-viewport -->
    </div> <!-- .tl-wrap -->
  </section>

  <div class="end-arrow" id="endArrow" aria-hidden="true">
    <svg width="36" height="36" viewBox="0 0 24 24" fill="none" aria-hidden="true">
      <path d="M12 4v14" stroke="#fff" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"></path>
      <path d="M6 12l6 6 6-6" stroke="#fff" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"></path>
    </svg>
  </div>

  <!-- GSAP + ScrollTrigger (apenas uma vez; remova outras inclusões no site) -->
  <script src="https://unpkg.com/gsap@3/dist/gsap.min.js"></script>
  <script src="https://unpkg.com/gsap@3/dist/ScrollTrigger.min.js"></script>

  <script>
    (function () {
      try { gsap.registerPlugin(ScrollTrigger); } catch (e) { /* já registrado possivelmente */ }

      const section = document.getElementById('timeline');
      if (!section) return;

      const viewport = section.querySelector('.tl-viewport');
      const stage = section.querySelector('.tl-stage');
      const track = document.getElementById('tlTrack');
      const bg = document.getElementById('tlBg');
      const items = Array.from(track.querySelectorAll('.tl-item, .tl-intro-item'));
      const endArrow = document.getElementById('endArrow');

      const PARALLAX = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--parallax')) || 0.78;

      function getEndExtra() {
        const px = parseFloat(section.dataset.endExtraPx);
        if (!Number.isNaN(px) && px > 0) return px;
        const vw = parseFloat(section.dataset.endExtraVw);
        if (!Number.isNaN(vw) && vw > 0) return (vw / 100) * window.innerWidth;
        return 1600;
      }

      // referencias de estado
      let tween = null, monitor = null;
      let finalShiftForTween = 0;
      let bgDisplayedWidth = 0;
      let itemCenters = []; // cache positions
      let currentActive = null;

      // AUTOSCROLL CONFIG (ajuste conforme necessário)
      // velocidade do auto-scroll em pixels por segundo (baixo = bem devagar)
      const AUTO_SPEED_PX_PER_SEC = 18; // <--- ajuste para acelerar / desacelerar
      // tempo (ms) sem interação do utilizador para considerar "inativo" e reativar o auto-scroll
      const IDLE_DELAY_MS = 600;

      // estado do auto-scroll
      let userInteracting = false;
      let lastUserInteractionTs = 0;
      let rafId = null;
      let lastFrameTs = 0;
      let autoRunning = false;

      function measure() {
        itemCenters = items.map(it => it.offsetLeft + (it.offsetWidth / 2));
      }

      function setup() {
        if (tween) { tween.kill(); tween = null; }
        if (monitor) { monitor.kill(); monitor = null; }

        // mobile: volta ao fluxo normal e desliga auto-scroll
        if (window.matchMedia('(max-width:720px)').matches) {
          track.style.transform = 'none';
          if (bg) bg.style.transform = 'translateY(-50%) translateX(0)';
          items.forEach(i => i.classList.remove('active'));
          if (endArrow) endArrow.classList.remove('visible');
          stopAutoScroll();
          return;
        }

        measure();

        const totalContentWidth = track.scrollWidth;
        const vw = viewport.clientWidth;
        const extra = Math.max(0, getEndExtra()) + 0;
        const distance = Math.max(0, totalContentWidth - vw + extra);

        if (!bg) {
          if (distance === 0) { track.style.transform = 'none'; }
          if (distance === 0) return;
        }

        const wantedBgWidth = Math.max(totalContentWidth + extra, vw);
        const cssMaxStr = getComputedStyle(bg).getPropertyValue('max-width') || '';
        let cssMax = Infinity;
        if (cssMaxStr && cssMaxStr.indexOf('px') !== -1) cssMax = parseFloat(cssMaxStr);
        const appliedBgWidth = Math.min(wantedBgWidth, cssMax || wantedBgWidth);

        bg.style.width = appliedBgWidth + 'px';
        bg.style.minWidth = appliedBgWidth + 'px';
        bgDisplayedWidth = bg.getBoundingClientRect().width || appliedBgWidth;

        let tipPx = bgDisplayedWidth;
        const dataTipX = bg.dataset.tipX;
        const dataTipPercent = bg.dataset.tipPercent;
        if (dataTipX && !Number.isNaN(parseFloat(dataTipX))) {
          tipPx = parseFloat(dataTipX);
        } else if (dataTipPercent && !Number.isNaN(parseFloat(dataTipPercent))) {
          const pct = parseFloat(dataTipPercent);
          tipPx = (pct / 100) * bgDisplayedWidth;
        }

        const desiredShiftAtEnd = (vw / 2) - tipPx; // px
        finalShiftForTween = desiredShiftAtEnd / PARALLAX;

        if (distance === 0) {
          track.style.transform = 'none';
          if (bg) bg.style.transform = `translateY(-50%) translateX(0)`;
          stopAutoScroll();
          return;
        }

        const useScrubDirect = true;

        tween = gsap.to(track, {
          x: -distance,
          ease: 'none',
          force3D: true,
          onUpdate: updateUI,
          scrollTrigger: {
            trigger: viewport,
            start: 'top top',
            end: () => '+=' + distance,
            scrub: useScrubDirect ? true : 0.12,
            pin: viewport,
            anticipatePin: 1,
            invalidateOnRefresh: true,
            onRefresh: () => { measure(); updateUI(); }
          }
        });

        monitor = ScrollTrigger.create({
          trigger: viewport,
          start: 'top top',
          end: () => '+=' + distance,
          onLeave: () => { if (endArrow) endArrow.classList.add('visible'); },
          onEnterBack: () => { if (endArrow) endArrow.classList.remove('visible'); },
          onUpdate: st => {
            if (endArrow) {
              if (st.progress >= 0.99) endArrow.classList.add('visible'); else endArrow.classList.remove('visible');
            }
          }
        });

        updateUI();
        startAutoScroll(); // (re)inicia auto-scroll quando a timeline está configurada
      }

      function updateUI() {
        const vpRect = viewport.getBoundingClientRect();
        const centerX = vpRect.left + vpRect.width / 2;
        const trackRect = track.getBoundingClientRect();
        const trackLeft = trackRect.left;

        let closest = null, minDist = Infinity;
        for (let i = 0; i < items.length; i++) {
          const screenCenter = trackLeft + itemCenters[i];
          const d = Math.abs(screenCenter - centerX);
          if (d < minDist) { minDist = d; closest = items[i]; }
        }

        if (closest !== currentActive) {
          if (currentActive) currentActive.classList.remove('active');
          if (closest) closest.classList.add('active');
          currentActive = closest;
        }

        if (bg && tween && tween.scrollTrigger) {
          const prog = tween.scrollTrigger.progress || 0;
          const shift = prog * finalShiftForTween * PARALLAX;
          bg.style.transform = `translateY(-50%) translateX(${shift}px)`;
        }
      }

      // clique: centra um card
      track.addEventListener('click', (e) => {
        const card = e.target.closest('.tl-item, .tl-intro-item');
        if (!card) return;

        const vpRect = viewport.getBoundingClientRect();
        const centerX = vpRect.left + vpRect.width / 2;
        const r = card.getBoundingClientRect();
        const cardCenter = r.left + (r.width / 2);
        const delta = cardCenter - centerX;

        if (tween && tween.scrollTrigger) {
          const st = tween.scrollTrigger;
          const currentProgress = st.progress;
          const distance = Math.max(0, track.scrollWidth - viewport.clientWidth + getEndExtra());
          const currentX = - (distance * currentProgress);
          const targetX = currentX - delta;
          const targetProg = Math.min(1, Math.max(0, -targetX / distance));

          const startScroll = (typeof st.start === 'number') ? st.start : window.scrollY;
          const targetScroll = Math.round(startScroll + (distance * targetProg));
          // Quando o utilizador clica, respeitamos isso como interação do utilizador.
          noteUserInteraction();
          window.scrollTo({ top: targetScroll, left: 0, behavior: 'smooth' });
        }
      });

      // --- Detecta interação do utilizador (para pausar temporariamente o auto-scroll) ---
      function noteUserInteraction() {
        userInteracting = true;
        lastUserInteractionTs = performance.now();
      }

      ['wheel', 'touchstart', 'pointerdown', 'keydown'].forEach(name => {
        window.addEventListener(name, () => noteUserInteraction(), { passive: true });
      });

      // Também marcaremos interação em scroll manual por teclado/trackpad (heurística)
      let lastScrollTs = 0;
      window.addEventListener('scroll', () => {
        // se o scroll foi recente e houve eventos de input, já foi marcado; caso contrário,
        // consideramos que pode ter sido uma interação manual (ex: teclado).
        const now = performance.now();
        if (now - lastScrollTs > 80) {
          // se não houver evento de input recente, marque a interação
          if (now - lastUserInteractionTs > 80) noteUserInteraction();
        }
        lastScrollTs = now;
      }, { passive: true });

      // --- Auto-scroll loop (usa rAF) ---
      function autoScrollStep(ts) {
        if (!lastFrameTs) lastFrameTs = ts;
        const dt = ts - lastFrameTs;
        lastFrameTs = ts;

        // se mobile ou sem tween, nada a fazer
        if (window.matchMedia('(max-width:720px)').matches || !tween || !tween.scrollTrigger) {
          stopAutoScroll();
          return;
        }

        // verifica se timeline já chegou ao fim
        const prog = tween.scrollTrigger.progress || 0;
        if (prog >= 1) {
          stopAutoScroll();
          return;
        }

        // considera inatividade do utilizador
        const idle = (performance.now() - lastUserInteractionTs) > IDLE_DELAY_MS;
        if (idle) {
          // se inativo, faça auto-scroll lento convertendo velocidade px/s para px por frame
          const dy = (AUTO_SPEED_PX_PER_SEC * (dt / 1000));
          // usa scrollBy sem behaviour 'smooth' para controle de frame a frame (mais previsível)
          window.scrollBy({ top: dy, left: 0, behavior: 'auto' });
        } else {
          // o utilizador interagiu recentemente — mantemos sem auto scroll
          // se não houver interação por um tempo, o idle será true novamente
        }

        // se o usuário não interagiu por um tempo, reset flag para poder voltar a auto
        if (idle) {
          userInteracting = false;
        }

        rafId = window.requestAnimationFrame(autoScrollStep);
      }

      function startAutoScroll() {
        if (autoRunning) return;
        lastFrameTs = 0;
        lastUserInteractionTs = performance.now(); // previne auto imediato caso o usuário esteja a manipular
        autoRunning = true;
        rafId = window.requestAnimationFrame(autoScrollStep);
      }

      function stopAutoScroll() {
        if (!autoRunning) return;
        autoRunning = false;
        if (rafId) { window.cancelAnimationFrame(rafId); rafId = null; }
        lastFrameTs = 0;
      }

      // eventos de ciclo de vida
      window.addEventListener('load', setup);
      window.addEventListener('resize', () => {
        clearTimeout(window._tl_resize);
        window._tl_resize = setTimeout(setup, 150);
      });

      // limpa rAF quando sai da página
      window.addEventListener('beforeunload', () => { stopAutoScroll(); });

    })();
    
  </script>



<script>
(function () {
  'use strict';

  var section = document.getElementById('timeline');
  if (!section) return;

  var header = document.querySelector('header.site-header');
  if (!header) {
    console.warn('[TIMELINE] header .site-header não encontrado.');
    return;
  }

  var HIDDEN_CLASS = 'site-header--hidden';

  // limpa qualquer estado anterior
  header.classList.remove(HIDDEN_CLASS);

  /*
    rootMargin explicado:
    - top:    -80px  → só considera "entrou" quando o topo passou 80px da viewport
    - bottom: -80px  → deixa de considerar "dentro" ANTES de sair totalmente
    Isso cria exatamente o "delay visual" que você quer
  */
  var observer = new IntersectionObserver(function (entries) {
    entries.forEach(function (entry) {
      if (entry.isIntersecting) {
        header.classList.add(HIDDEN_CLASS);
      } else {
        header.classList.remove(HIDDEN_CLASS);
      }
    });
  }, {
    root: null,
    threshold: 0,
    rootMargin: '-1000px 0px 0px 0px'
  });

  observer.observe(section);

  // debug / controle externo
  window._timelineHeaderToggle = {
    observer: observer,
    header: header,
    forceShow: function () { header.classList.remove(HIDDEN_CLASS); },
    forceHide: function () { header.classList.add(HIDDEN_CLASS); },
    destroy: function () {
      observer.disconnect();
      header.classList.remove(HIDDEN_CLASS);
    }
  };
})();
</script>




</body>

</html>
